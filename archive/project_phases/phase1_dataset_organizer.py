#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Dataset Organizer - Phase 1
‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö dataset ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
"""

import os
import shutil
import json
from pathlib import Path
from PIL import Image
import re
from collections import defaultdict
import datetime

class DatasetOrganizer:
    def __init__(self, source_dir="Data set", target_dir="organized_dataset"):
        self.source_dir = Path(source_dir)
        self.target_dir = Path(target_dir)
        self.stats = defaultdict(lambda: defaultdict(int))
        
        # Class mapping
        self.class_mapping = {
            "‡∏õ‡∏£‡∏Å‡πÇ‡∏û‡∏ò‡∏¥‡πå9‡πÉ‡∏ö": "prok_bodhi_9_leaves",
            "‡∏û‡∏£‡∏∞‡∏™‡∏°‡πÄ‡∏î‡πá‡∏à‡∏õ‡∏£‡∏∞‡∏ò‡∏≤‡∏ô‡∏û‡∏£‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏û‡∏∏‡∏ó‡∏ò‡∏Å‡∏ß‡∏±‡∏Å": "somdej_pratanporn_buddhagavak", 
            "‡∏û‡∏£‡∏∞‡∏™‡∏µ‡∏ß‡∏•‡∏µ": "phra_sivali",
            "‡∏ß‡∏±‡∏î‡∏´‡∏ô‡∏≠‡∏á‡∏≠‡∏µ‡∏î‡∏∏‡∏Å": "wat_nong_e_duk",
            "‡∏´‡∏•‡∏±‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô": "portrait_back",
            "‡πÅ‡∏´‡∏ß‡∏Å‡∏°‡πà‡∏≤‡∏ô": "waek_man"
        }
        
    def analyze_current_dataset(self):
        """‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå dataset ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        print("üîç ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå Dataset ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô...")
        print("=" * 50)
        
        analysis = {}
        
        for class_folder in self.source_dir.iterdir():
            if not class_folder.is_dir():
                continue
                
            class_name = class_folder.name
            english_name = self.class_mapping.get(class_name, class_name)
            
            print(f"\nüìÅ {class_name}")
            print(f"   English: {english_name}")
            
            # Count files
            total_files = 0
            front_files = 0
            back_files = 0
            subfolders = 0
            
            # Count direct files
            for file in class_folder.iterdir():
                if file.is_file() and file.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                    total_files += 1
                    filename = file.name.lower()
                    if 'front' in filename:
                        front_files += 1
                    elif 'back' in filename:
                        back_files += 1
                elif file.is_dir():
                    subfolders += 1
                    # Count files in subfolders
                    for subfile in file.rglob("*"):
                        if subfile.is_file() and subfile.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                            total_files += 1
                            filename = subfile.name.lower()
                            if 'front' in filename:
                                front_files += 1
                            elif 'back' in filename:
                                back_files += 1
            
            analysis[class_name] = {
                "english_name": english_name,
                "total_files": total_files,
                "front_files": front_files,
                "back_files": back_files,
                "subfolders": subfolders,
                "other_files": total_files - front_files - back_files
            }
            
            print(f"   üìä ‡∏£‡∏ß‡∏°: {total_files} ‡πÑ‡∏ü‡∏•‡πå")
            print(f"   üé≠ ‡∏´‡∏ô‡πâ‡∏≤: {front_files} ‡πÑ‡∏ü‡∏•‡πå")
            print(f"   üîô ‡∏´‡∏•‡∏±‡∏á: {back_files} ‡πÑ‡∏ü‡∏•‡πå")
            print(f"   üìÇ ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢: {subfolders}")
            print(f"   ‚ùì ‡∏≠‡∏∑‡πà‡∏ô‡πÜ: {total_files - front_files - back_files} ‡πÑ‡∏ü‡∏•‡πå")
        
        return analysis
    
    def create_organized_structure(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà"""
        print(f"\nüèóÔ∏è ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô {self.target_dir}")
        
        # Create main structure
        structure = {
            "raw": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö",
            "processed": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡πâ‡∏ß", 
            "augmented": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô",
            "splits": "‡πÅ‡∏ö‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• train/val/test",
            "metadata": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏ï‡∏≤"
        }
        
        for folder, description in structure.items():
            folder_path = self.target_dir / folder
            folder_path.mkdir(parents=True, exist_ok=True)
            print(f"   ‚úÖ {folder}/ - {description}")
            
            if folder in ["raw", "processed", "augmented"]:
                # Create class subfolders
                for thai_name, eng_name in self.class_mapping.items():
                    class_folder = folder_path / eng_name
                    class_folder.mkdir(exist_ok=True)
                    
                    # Create front/back subfolders
                    (class_folder / "front").mkdir(exist_ok=True)
                    (class_folder / "back").mkdir(exist_ok=True)
                    
            elif folder == "splits":
                for split in ["train", "validation", "test"]:
                    split_folder = folder_path / split
                    split_folder.mkdir(exist_ok=True)
                    for thai_name, eng_name in self.class_mapping.items():
                        class_folder = split_folder / eng_name
                        class_folder.mkdir(exist_ok=True)
                        (class_folder / "front").mkdir(exist_ok=True)
                        (class_folder / "back").mkdir(exist_ok=True)
        
        print(f"   ‚úÖ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô!")
        
    def copy_and_organize_files(self):
        """‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡πÑ‡∏ü‡∏•‡πå"""
        print(f"\nüìã ‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡πÅ‡∏•‡∏∞‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå...")
        
        copy_stats = defaultdict(lambda: defaultdict(int))
        
        for class_folder in self.source_dir.iterdir():
            if not class_folder.is_dir():
                continue
                
            class_name = class_folder.name
            english_name = self.class_mapping.get(class_name, class_name)
            
            if english_name not in self.class_mapping.values():
                print(f"   ‚ö†Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°: {class_name} (‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)")
                continue
                
            print(f"\n   üìÅ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: {class_name}")
            
            # Create target folders
            target_class = self.target_dir / "raw" / english_name
            
            # Process all files in class folder and subfolders
            all_files = []
            
            # Direct files
            for file in class_folder.iterdir():
                if file.is_file() and file.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                    all_files.append(file)
            
            # Files in subfolders  
            for file in class_folder.rglob("*"):
                if file.is_file() and file.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                    if file not in all_files:  # Avoid duplicates
                        all_files.append(file)
            
            # Copy and organize files
            for file in all_files:
                try:
                    # Determine if front or back
                    filename = file.name.lower()
                    
                    if 'front' in filename:
                        target_folder = target_class / "front"
                        copy_stats[english_name]["front"] += 1
                    elif 'back' in filename:
                        target_folder = target_class / "back"  
                        copy_stats[english_name]["back"] += 1
                    else:
                        # Try to guess from filename patterns
                        if any(pattern in filename for pattern in ['‡∏´‡∏ô‡πâ‡∏≤', 'front', 'f']):
                            target_folder = target_class / "front"
                            copy_stats[english_name]["front"] += 1
                        elif any(pattern in filename for pattern in ['‡∏´‡∏•‡∏±‡∏á', 'back', 'b']):
                            target_folder = target_class / "back"
                            copy_stats[english_name]["back"] += 1
                        else:
                            # Default to front if unclear
                            target_folder = target_class / "front"
                            copy_stats[english_name]["front"] += 1
                            copy_stats[english_name]["unclear"] += 1
                    
                    # Generate new filename
                    counter = copy_stats[english_name]["front"] + copy_stats[english_name]["back"]
                    side = "front" if "front" in str(target_folder) else "back"
                    new_filename = f"{english_name}_{side}_{counter:03d}{file.suffix}"
                    
                    # Copy file
                    target_file = target_folder / new_filename
                    shutil.copy2(file, target_file)
                    
                except Exception as e:
                    print(f"      ‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î {file.name}: {e}")
                    copy_stats[english_name]["errors"] += 1
            
            print(f"      ‚úÖ ‡∏´‡∏ô‡πâ‡∏≤: {copy_stats[english_name]['front']} ‡πÑ‡∏ü‡∏•‡πå")
            print(f"      ‚úÖ ‡∏´‡∏•‡∏±‡∏á: {copy_stats[english_name]['back']} ‡πÑ‡∏ü‡∏•‡πå")
            if copy_stats[english_name]["unclear"] > 0:
                print(f"      ‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô: {copy_stats[english_name]['unclear']} ‡πÑ‡∏ü‡∏•‡πå")
            if copy_stats[english_name]["errors"] > 0:
                print(f"      ‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {copy_stats[english_name]['errors']} ‡πÑ‡∏ü‡∏•‡πå")
        
        return copy_stats
    
    def generate_metadata(self, analysis, copy_stats):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå metadata"""
        print(f"\nüìÑ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå metadata...")
        
        metadata = {
            "created_at": datetime.datetime.now().isoformat(),
            "source_directory": str(self.source_dir),
            "target_directory": str(self.target_dir),
            "classes": self.class_mapping,
            "original_analysis": analysis,
            "copy_statistics": dict(copy_stats),
            "total_organized_files": sum(
                stats["front"] + stats["back"] 
                for stats in copy_stats.values()
            )
        }
        
        # Save metadata
        metadata_file = self.target_dir / "metadata" / "organization_log.json"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, ensure_ascii=False, indent=2)
        
        print(f"   ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å metadata ‡πÉ‡∏ô {metadata_file}")
        
        # Create summary
        summary_file = self.target_dir / "metadata" / "summary.txt"
        with open(summary_file, 'w', encoding='utf-8') as f:
            f.write("üóÇÔ∏è Dataset Organization Summary\n")
            f.write("=" * 40 + "\n\n")
            f.write(f"üìÖ Created: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("üìä Class Statistics:\n")
            for class_name, stats in copy_stats.items():
                total = stats["front"] + stats["back"]
                f.write(f"  {class_name}:\n")
                f.write(f"    - Total: {total} files\n")
                f.write(f"    - Front: {stats['front']} files\n") 
                f.write(f"    - Back: {stats['back']} files\n")
                if stats["unclear"] > 0:
                    f.write(f"    - Unclear: {stats['unclear']} files\n")
                f.write("\n")
        
        print(f"   ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å summary ‡πÉ‡∏ô {summary_file}")
        
        return metadata
    
    def run_phase1(self):
        """‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö Phase 1"""
        print("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° Phase 1: ‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö Dataset")
        print("=" * 60)
        
        # Step 1: Analyze
        analysis = self.analyze_current_dataset()
        
        # Step 2: Create structure
        self.create_organized_structure()
        
        # Step 3: Copy and organize
        copy_stats = self.copy_and_organize_files()
        
        # Step 4: Generate metadata
        metadata = self.generate_metadata(analysis, copy_stats)
        
        print(f"\nüéâ Phase 1 ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!")
        print(f"üìÅ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà: {self.target_dir}")
        print(f"üìã ‡∏£‡∏ß‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö: {metadata['total_organized_files']} ‡πÑ‡∏ü‡∏•‡πå")
        
        return metadata

def main():
    organizer = DatasetOrganizer()
    metadata = organizer.run_phase1()
    
    print(f"\nüìà ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏£‡∏∏‡∏õ:")
    for class_name, stats in metadata['copy_statistics'].items():
        total = stats.get('front', 0) + stats.get('back', 0)
        print(f"  üìÅ {class_name}: {total} ‡πÑ‡∏ü‡∏•‡πå ({stats.get('front', 0)} ‡∏´‡∏ô‡πâ‡∏≤, {stats.get('back', 0)} ‡∏´‡∏•‡∏±‡∏á)")

if __name__ == "__main__":
    main()